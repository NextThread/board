{"ast":null,"code":"import { Transport } from \"../transport.js\";\nimport { nextTick } from \"./websocket-constructor.js\";\nimport { encodePacketToBinary, decodePacketFromBinary } from \"engine.io-parser\";\nfunction shouldIncludeBinaryHeader(packet, encoded) {\n  // 48 === \"0\".charCodeAt(0) (OPEN packet type)\n  // 54 === \"6\".charCodeAt(0) (NOOP packet type)\n  return packet.type === \"message\" && typeof packet.data !== \"string\" && encoded[0] >= 48 && encoded[0] <= 54;\n}\nexport class WT extends Transport {\n  get name() {\n    return \"webtransport\";\n  }\n  doOpen() {\n    // @ts-ignore\n    if (typeof WebTransport !== \"function\") {\n      return;\n    }\n    // @ts-ignore\n    this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n    this.transport.closed.then(() => {\n      this.onClose();\n    }).catch(err => {\n      this.onError(\"webtransport error\", err);\n    });\n    // note: we could have used async/await, but that would require some additional polyfills\n    this.transport.ready.then(() => {\n      this.transport.createBidirectionalStream().then(stream => {\n        const reader = stream.readable.getReader();\n        this.writer = stream.writable.getWriter();\n        let binaryFlag;\n        const read = () => {\n          reader.read().then(_ref => {\n            let {\n              done,\n              value\n            } = _ref;\n            if (done) {\n              return;\n            }\n            if (!binaryFlag && value.byteLength === 1 && value[0] === 54) {\n              binaryFlag = true;\n            } else {\n              // TODO expose binarytype\n              this.onPacket(decodePacketFromBinary(value, binaryFlag, \"arraybuffer\"));\n              binaryFlag = false;\n            }\n            read();\n          }).catch(err => {});\n        };\n        read();\n        const handshake = this.query.sid ? `0{\"sid\":\"${this.query.sid}\"}` : \"0\";\n        this.writer.write(new TextEncoder().encode(handshake)).then(() => this.onOpen());\n      });\n    });\n  }\n  write(packets) {\n    this.writable = false;\n    for (let i = 0; i < packets.length; i++) {\n      const packet = packets[i];\n      const lastPacket = i === packets.length - 1;\n      encodePacketToBinary(packet, data => {\n        if (shouldIncludeBinaryHeader(packet, data)) {\n          this.writer.write(Uint8Array.of(54));\n        }\n        this.writer.write(data).then(() => {\n          if (lastPacket) {\n            nextTick(() => {\n              this.writable = true;\n              this.emitReserved(\"drain\");\n            }, this.setTimeoutFn);\n          }\n        });\n      });\n    }\n  }\n  doClose() {\n    var _a;\n    (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n  }\n}","map":{"version":3,"names":["Transport","nextTick","encodePacketToBinary","decodePacketFromBinary","shouldIncludeBinaryHeader","packet","encoded","type","data","WT","name","doOpen","WebTransport","transport","createUri","opts","transportOptions","closed","then","onClose","catch","err","onError","ready","createBidirectionalStream","stream","reader","readable","getReader","writer","writable","getWriter","binaryFlag","read","_ref","done","value","byteLength","onPacket","handshake","query","sid","write","TextEncoder","encode","onOpen","packets","i","length","lastPacket","Uint8Array","of","emitReserved","setTimeoutFn","doClose","_a","close"],"sources":["C:/Users/royan/realtime-white-board/frontend/node_modules/engine.io-client/build/esm/transports/webtransport.js"],"sourcesContent":["import { Transport } from \"../transport.js\";\r\nimport { nextTick } from \"./websocket-constructor.js\";\r\nimport { encodePacketToBinary, decodePacketFromBinary, } from \"engine.io-parser\";\r\nfunction shouldIncludeBinaryHeader(packet, encoded) {\r\n    // 48 === \"0\".charCodeAt(0) (OPEN packet type)\r\n    // 54 === \"6\".charCodeAt(0) (NOOP packet type)\r\n    return (packet.type === \"message\" &&\r\n        typeof packet.data !== \"string\" &&\r\n        encoded[0] >= 48 &&\r\n        encoded[0] <= 54);\r\n}\r\nexport class WT extends Transport {\r\n    get name() {\r\n        return \"webtransport\";\r\n    }\r\n    doOpen() {\r\n        // @ts-ignore\r\n        if (typeof WebTransport !== \"function\") {\r\n            return;\r\n        }\r\n        // @ts-ignore\r\n        this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\r\n        this.transport.closed\r\n            .then(() => {\r\n            this.onClose();\r\n        })\r\n            .catch((err) => {\r\n            this.onError(\"webtransport error\", err);\r\n        });\r\n        // note: we could have used async/await, but that would require some additional polyfills\r\n        this.transport.ready.then(() => {\r\n            this.transport.createBidirectionalStream().then((stream) => {\r\n                const reader = stream.readable.getReader();\r\n                this.writer = stream.writable.getWriter();\r\n                let binaryFlag;\r\n                const read = () => {\r\n                    reader\r\n                        .read()\r\n                        .then(({ done, value }) => {\r\n                        if (done) {\r\n                            return;\r\n                        }\r\n                        if (!binaryFlag && value.byteLength === 1 && value[0] === 54) {\r\n                            binaryFlag = true;\r\n                        }\r\n                        else {\r\n                            // TODO expose binarytype\r\n                            this.onPacket(decodePacketFromBinary(value, binaryFlag, \"arraybuffer\"));\r\n                            binaryFlag = false;\r\n                        }\r\n                        read();\r\n                    })\r\n                        .catch((err) => {\r\n                    });\r\n                };\r\n                read();\r\n                const handshake = this.query.sid ? `0{\"sid\":\"${this.query.sid}\"}` : \"0\";\r\n                this.writer\r\n                    .write(new TextEncoder().encode(handshake))\r\n                    .then(() => this.onOpen());\r\n            });\r\n        });\r\n    }\r\n    write(packets) {\r\n        this.writable = false;\r\n        for (let i = 0; i < packets.length; i++) {\r\n            const packet = packets[i];\r\n            const lastPacket = i === packets.length - 1;\r\n            encodePacketToBinary(packet, (data) => {\r\n                if (shouldIncludeBinaryHeader(packet, data)) {\r\n                    this.writer.write(Uint8Array.of(54));\r\n                }\r\n                this.writer.write(data).then(() => {\r\n                    if (lastPacket) {\r\n                        nextTick(() => {\r\n                            this.writable = true;\r\n                            this.emitReserved(\"drain\");\r\n                        }, this.setTimeoutFn);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n    doClose() {\r\n        var _a;\r\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}