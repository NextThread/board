{"ast":null,"code":"import _classCallCheck from \"C:/Users/royan/realtime-white-board/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/royan/realtime-white-board/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/royan/realtime-white-board/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/royan/realtime-white-board/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Transport } from \"../transport.js\";\nimport { nextTick } from \"./websocket-constructor.js\";\nimport { encodePacketToBinary, decodePacketFromBinary } from \"engine.io-parser\";\nfunction shouldIncludeBinaryHeader(packet, encoded) {\n  // 48 === \"0\".charCodeAt(0) (OPEN packet type)\n  // 54 === \"6\".charCodeAt(0) (NOOP packet type)\n  return packet.type === \"message\" && typeof packet.data !== \"string\" && encoded[0] >= 48 && encoded[0] <= 54;\n}\nexport var WT = /*#__PURE__*/function (_Transport) {\n  _inherits(WT, _Transport);\n  var _super = _createSuper(WT);\n  function WT() {\n    _classCallCheck(this, WT);\n    return _super.apply(this, arguments);\n  }\n  _createClass(WT, [{\n    key: \"name\",\n    get: function get() {\n      return \"webtransport\";\n    }\n  }, {\n    key: \"doOpen\",\n    value: function doOpen() {\n      var _this = this;\n      // @ts-ignore\n      if (typeof WebTransport !== \"function\") {\n        return;\n      }\n      // @ts-ignore\n      this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n      this.transport.closed.then(function () {\n        _this.onClose();\n      }).catch(function (err) {\n        _this.onError(\"webtransport error\", err);\n      });\n      // note: we could have used async/await, but that would require some additional polyfills\n      this.transport.ready.then(function () {\n        _this.transport.createBidirectionalStream().then(function (stream) {\n          var reader = stream.readable.getReader();\n          _this.writer = stream.writable.getWriter();\n          var binaryFlag;\n          var read = function read() {\n            reader.read().then(function (_ref) {\n              var done = _ref.done,\n                value = _ref.value;\n              if (done) {\n                return;\n              }\n              if (!binaryFlag && value.byteLength === 1 && value[0] === 54) {\n                binaryFlag = true;\n              } else {\n                // TODO expose binarytype\n                _this.onPacket(decodePacketFromBinary(value, binaryFlag, \"arraybuffer\"));\n                binaryFlag = false;\n              }\n              read();\n            }).catch(function (err) {});\n          };\n          read();\n          var handshake = _this.query.sid ? \"0{\\\"sid\\\":\\\"\".concat(_this.query.sid, \"\\\"}\") : \"0\";\n          _this.writer.write(new TextEncoder().encode(handshake)).then(function () {\n            return _this.onOpen();\n          });\n        });\n      });\n    }\n  }, {\n    key: \"write\",\n    value: function write(packets) {\n      var _this2 = this;\n      this.writable = false;\n      var _loop = function _loop() {\n        var packet = packets[i];\n        var lastPacket = i === packets.length - 1;\n        encodePacketToBinary(packet, function (data) {\n          if (shouldIncludeBinaryHeader(packet, data)) {\n            _this2.writer.write(Uint8Array.of(54));\n          }\n          _this2.writer.write(data).then(function () {\n            if (lastPacket) {\n              nextTick(function () {\n                _this2.writable = true;\n                _this2.emitReserved(\"drain\");\n              }, _this2.setTimeoutFn);\n            }\n          });\n        });\n      };\n      for (var i = 0; i < packets.length; i++) {\n        _loop();\n      }\n    }\n  }, {\n    key: \"doClose\",\n    value: function doClose() {\n      var _a;\n      (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n    }\n  }]);\n  return WT;\n}(Transport);","map":{"version":3,"names":["Transport","nextTick","encodePacketToBinary","decodePacketFromBinary","shouldIncludeBinaryHeader","packet","encoded","type","data","WT","_Transport","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","get","value","doOpen","_this","WebTransport","transport","createUri","opts","transportOptions","name","closed","then","onClose","catch","err","onError","ready","createBidirectionalStream","stream","reader","readable","getReader","writer","writable","getWriter","binaryFlag","read","_ref","done","byteLength","onPacket","handshake","query","sid","concat","write","TextEncoder","encode","onOpen","packets","_this2","_loop","i","lastPacket","length","Uint8Array","of","emitReserved","setTimeoutFn","doClose","_a","close"],"sources":["C:/Users/royan/realtime-white-board/frontend/node_modules/engine.io-client/build/esm/transports/webtransport.js"],"sourcesContent":["import { Transport } from \"../transport.js\";\r\nimport { nextTick } from \"./websocket-constructor.js\";\r\nimport { encodePacketToBinary, decodePacketFromBinary, } from \"engine.io-parser\";\r\nfunction shouldIncludeBinaryHeader(packet, encoded) {\r\n    // 48 === \"0\".charCodeAt(0) (OPEN packet type)\r\n    // 54 === \"6\".charCodeAt(0) (NOOP packet type)\r\n    return (packet.type === \"message\" &&\r\n        typeof packet.data !== \"string\" &&\r\n        encoded[0] >= 48 &&\r\n        encoded[0] <= 54);\r\n}\r\nexport class WT extends Transport {\r\n    get name() {\r\n        return \"webtransport\";\r\n    }\r\n    doOpen() {\r\n        // @ts-ignore\r\n        if (typeof WebTransport !== \"function\") {\r\n            return;\r\n        }\r\n        // @ts-ignore\r\n        this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\r\n        this.transport.closed\r\n            .then(() => {\r\n            this.onClose();\r\n        })\r\n            .catch((err) => {\r\n            this.onError(\"webtransport error\", err);\r\n        });\r\n        // note: we could have used async/await, but that would require some additional polyfills\r\n        this.transport.ready.then(() => {\r\n            this.transport.createBidirectionalStream().then((stream) => {\r\n                const reader = stream.readable.getReader();\r\n                this.writer = stream.writable.getWriter();\r\n                let binaryFlag;\r\n                const read = () => {\r\n                    reader\r\n                        .read()\r\n                        .then(({ done, value }) => {\r\n                        if (done) {\r\n                            return;\r\n                        }\r\n                        if (!binaryFlag && value.byteLength === 1 && value[0] === 54) {\r\n                            binaryFlag = true;\r\n                        }\r\n                        else {\r\n                            // TODO expose binarytype\r\n                            this.onPacket(decodePacketFromBinary(value, binaryFlag, \"arraybuffer\"));\r\n                            binaryFlag = false;\r\n                        }\r\n                        read();\r\n                    })\r\n                        .catch((err) => {\r\n                    });\r\n                };\r\n                read();\r\n                const handshake = this.query.sid ? `0{\"sid\":\"${this.query.sid}\"}` : \"0\";\r\n                this.writer\r\n                    .write(new TextEncoder().encode(handshake))\r\n                    .then(() => this.onOpen());\r\n            });\r\n        });\r\n    }\r\n    write(packets) {\r\n        this.writable = false;\r\n        for (let i = 0; i < packets.length; i++) {\r\n            const packet = packets[i];\r\n            const lastPacket = i === packets.length - 1;\r\n            encodePacketToBinary(packet, (data) => {\r\n                if (shouldIncludeBinaryHeader(packet, data)) {\r\n                    this.writer.write(Uint8Array.of(54));\r\n                }\r\n                this.writer.write(data).then(() => {\r\n                    if (lastPacket) {\r\n                        nextTick(() => {\r\n                            this.writable = true;\r\n                            this.emitReserved(\"drain\");\r\n                        }, this.setTimeoutFn);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n    doClose() {\r\n        var _a;\r\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}