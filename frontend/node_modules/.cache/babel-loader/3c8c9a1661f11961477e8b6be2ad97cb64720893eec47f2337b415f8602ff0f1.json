{"ast":null,"code":"import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\nimport { decodePacket } from \"./decodePacket.js\";\nvar SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nvar encodePayload = function encodePayload(packets, callback) {\n  // some packets may be added to the array while encoding, so the initial length must be saved\n  var length = packets.length;\n  var encodedPackets = new Array(length);\n  var count = 0;\n  packets.forEach(function (packet, i) {\n    // force base64 encoding for binary packets\n    encodePacket(packet, false, function (encodedPacket) {\n      encodedPackets[i] = encodedPacket;\n      if (++count === length) {\n        callback(encodedPackets.join(SEPARATOR));\n      }\n    });\n  });\n};\nvar decodePayload = function decodePayload(encodedPayload, binaryType) {\n  var encodedPackets = encodedPayload.split(SEPARATOR);\n  var packets = [];\n  for (var i = 0; i < encodedPackets.length; i++) {\n    var decodedPacket = decodePacket(encodedPackets[i], binaryType);\n    packets.push(decodedPacket);\n    if (decodedPacket.type === \"error\") {\n      break;\n    }\n  }\n  return packets;\n};\nvar TEXT_DECODER;\nexport function decodePacketFromBinary(data, isBinary, binaryType) {\n  if (!TEXT_DECODER) {\n    // lazily created for compatibility with old browser platforms\n    TEXT_DECODER = new TextDecoder();\n  }\n  // 48 === \"0\".charCodeAt(0) (OPEN packet type)\n  // 54 === \"6\".charCodeAt(0) (NOOP packet type)\n  var isPlainBinary = isBinary || data[0] < 48 || data[0] > 54;\n  return decodePacket(isPlainBinary ? data : TEXT_DECODER.decode(data), binaryType);\n}\nexport var protocol = 4;\nexport { encodePacket, encodePacketToBinary, encodePayload, decodePacket, decodePayload };","map":{"version":3,"names":["encodePacket","encodePacketToBinary","decodePacket","SEPARATOR","String","fromCharCode","encodePayload","packets","callback","length","encodedPackets","Array","count","forEach","packet","i","encodedPacket","join","decodePayload","encodedPayload","binaryType","split","decodedPacket","push","type","TEXT_DECODER","decodePacketFromBinary","data","isBinary","TextDecoder","isPlainBinary","decode","protocol"],"sources":["C:/Users/royan/realtime-white-board/frontend/node_modules/engine.io-parser/build/esm/index.js"],"sourcesContent":["import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\r\nimport { decodePacket } from \"./decodePacket.js\";\r\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\r\nconst encodePayload = (packets, callback) => {\r\n    // some packets may be added to the array while encoding, so the initial length must be saved\r\n    const length = packets.length;\r\n    const encodedPackets = new Array(length);\r\n    let count = 0;\r\n    packets.forEach((packet, i) => {\r\n        // force base64 encoding for binary packets\r\n        encodePacket(packet, false, encodedPacket => {\r\n            encodedPackets[i] = encodedPacket;\r\n            if (++count === length) {\r\n                callback(encodedPackets.join(SEPARATOR));\r\n            }\r\n        });\r\n    });\r\n};\r\nconst decodePayload = (encodedPayload, binaryType) => {\r\n    const encodedPackets = encodedPayload.split(SEPARATOR);\r\n    const packets = [];\r\n    for (let i = 0; i < encodedPackets.length; i++) {\r\n        const decodedPacket = decodePacket(encodedPackets[i], binaryType);\r\n        packets.push(decodedPacket);\r\n        if (decodedPacket.type === \"error\") {\r\n            break;\r\n        }\r\n    }\r\n    return packets;\r\n};\r\nlet TEXT_DECODER;\r\nexport function decodePacketFromBinary(data, isBinary, binaryType) {\r\n    if (!TEXT_DECODER) {\r\n        // lazily created for compatibility with old browser platforms\r\n        TEXT_DECODER = new TextDecoder();\r\n    }\r\n    // 48 === \"0\".charCodeAt(0) (OPEN packet type)\r\n    // 54 === \"6\".charCodeAt(0) (NOOP packet type)\r\n    const isPlainBinary = isBinary || data[0] < 48 || data[0] > 54;\r\n    return decodePacket(isPlainBinary ? data : TEXT_DECODER.decode(data), binaryType);\r\n}\r\nexport const protocol = 4;\r\nexport { encodePacket, encodePacketToBinary, encodePayload, decodePacket, decodePayload };\r\n"],"mappings":"AAAA,SAASA,YAAY,EAAEC,oBAAoB,QAAQ,mBAAmB;AACtE,SAASC,YAAY,QAAQ,mBAAmB;AAChD,IAAMC,SAAS,GAAGC,MAAM,CAACC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC;AAC3C,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAIC,OAAO,EAAEC,QAAQ,EAAK;EACzC;EACA,IAAMC,MAAM,GAAGF,OAAO,CAACE,MAAM;EAC7B,IAAMC,cAAc,GAAG,IAAIC,KAAK,CAACF,MAAM,CAAC;EACxC,IAAIG,KAAK,GAAG,CAAC;EACbL,OAAO,CAACM,OAAO,CAAC,UAACC,MAAM,EAAEC,CAAC,EAAK;IAC3B;IACAf,YAAY,CAACc,MAAM,EAAE,KAAK,EAAE,UAAAE,aAAa,EAAI;MACzCN,cAAc,CAACK,CAAC,CAAC,GAAGC,aAAa;MACjC,IAAI,EAAEJ,KAAK,KAAKH,MAAM,EAAE;QACpBD,QAAQ,CAACE,cAAc,CAACO,IAAI,CAACd,SAAS,CAAC,CAAC;MAC5C;IACJ,CAAC,CAAC;EACN,CAAC,CAAC;AACN,CAAC;AACD,IAAMe,aAAa,GAAG,SAAhBA,aAAaA,CAAIC,cAAc,EAAEC,UAAU,EAAK;EAClD,IAAMV,cAAc,GAAGS,cAAc,CAACE,KAAK,CAAClB,SAAS,CAAC;EACtD,IAAMI,OAAO,GAAG,EAAE;EAClB,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,cAAc,CAACD,MAAM,EAAEM,CAAC,EAAE,EAAE;IAC5C,IAAMO,aAAa,GAAGpB,YAAY,CAACQ,cAAc,CAACK,CAAC,CAAC,EAAEK,UAAU,CAAC;IACjEb,OAAO,CAACgB,IAAI,CAACD,aAAa,CAAC;IAC3B,IAAIA,aAAa,CAACE,IAAI,KAAK,OAAO,EAAE;MAChC;IACJ;EACJ;EACA,OAAOjB,OAAO;AAClB,CAAC;AACD,IAAIkB,YAAY;AAChB,OAAO,SAASC,sBAAsBA,CAACC,IAAI,EAAEC,QAAQ,EAAER,UAAU,EAAE;EAC/D,IAAI,CAACK,YAAY,EAAE;IACf;IACAA,YAAY,GAAG,IAAII,WAAW,CAAC,CAAC;EACpC;EACA;EACA;EACA,IAAMC,aAAa,GAAGF,QAAQ,IAAID,IAAI,CAAC,CAAC,CAAC,GAAG,EAAE,IAAIA,IAAI,CAAC,CAAC,CAAC,GAAG,EAAE;EAC9D,OAAOzB,YAAY,CAAC4B,aAAa,GAAGH,IAAI,GAAGF,YAAY,CAACM,MAAM,CAACJ,IAAI,CAAC,EAAEP,UAAU,CAAC;AACrF;AACA,OAAO,IAAMY,QAAQ,GAAG,CAAC;AACzB,SAAShC,YAAY,EAAEC,oBAAoB,EAAEK,aAAa,EAAEJ,YAAY,EAAEgB,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}